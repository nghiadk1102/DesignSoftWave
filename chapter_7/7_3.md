7.3 decorator(Trang trí)
Mẫu thiết kế decorator (còn được gọi là “wrapper”) là một mẫu khuyến khích việc sao chép API giữa các lớp. Đối tượng decorator lấy một đối tượng hiện có và mở rộng chức năng của nó; nó cung cấp một API tương tự hoặc giống hệt đối tượng bên dưới và các phương thức của nó gọi các phương thức của đối tượng bên dưới. Trong ví dụ Java I / O từ Chương 4, lớp BufferedInputStream là một trình trang trí: được cung cấp một đối tượng InputStream, nó cung cấp cùng một API nhưng giới thiệu bộ đệm. Ví dụ: khi phương thức đọc của nó được gọi để đọc một ký tự, nó sẽ gọi phương thức đọc trên InputStream bên dưới để đọc một khối lớn hơn nhiều và lưu các ký tự thừa để đáp ứng các lệnh gọi đọc trong tương lai. Một ví dụ khác xảy ra trong các hệ thống cửa sổ: một lớp Window triển khai một dạng cửa sổ đơn giản không thể cuộn được và một lớp ScrollableWindow trang trí lớp Window bằng cách thêm các thanh cuộn ngang và dọc. Động lực cho các nhà trang trí là tách các phần mở rộng có mục đích đặc biệt của một lớp khỏi một lõi chung chung hơn. Tuy nhiên, các lớp decorator có xu hướng nông cạn: chúng đưa vào một lượng lớn bảng tạo sẵn cho một lượng nhỏ chức năng mới. Các lớp trang trí thường chứa nhiều phương thức truyền qua. Dễ dàng sử dụng quá mức mẫu trang trí, tạo ra một lớp mới cho mọi tính năng mới nhỏ. Điều này dẫn đến sự bùng nổ của các lớp nông, chẳng hạn như ví dụ Java I / O.

Trước khi tạo một lớp trang trí, hãy xem xét các lựa chọn thay thế như sau: Bạn có thể thêm chức năng mới trực tiếp vào lớp bên dưới, thay vì tạo một lớp trang trí không? Điều này có ý nghĩa nếu chức năng mới có mục đích tương đối chung, hoặc nếu nó có liên quan về mặt logic với lớp bên dưới hoặc nếu hầu hết các cách sử dụng lớp bên dưới cũng sẽ sử dụng chức năng mới. Ví dụ: hầu như tất cả những người tạo Java InputStream cũng sẽ tạo BufferedInputStream và bộ đệm là một phần tự nhiên của I / O, vì vậy các lớp này nên được kết hợp với nhau. Nếu chức năng mới được chuyên biệt cho một trường hợp sử dụng cụ thể, liệu hợp nhất nó với trường hợp sử dụng, thay vì tạo một lớp riêng biệt có hợp lý không? Bạn có thể hợp nhất chức năng mới với một trình trang trí hiện có, thay vì tạo một trình trang trí mới không? Điều này sẽ dẫn đến một lớp trang trí sâu hơn thay vì nhiều lớp nông. Cuối cùng, hãy tự hỏi bản thân xem chức năng mới có thực sự cần thiết để bao bọc chức năng hiện có không: bạn có thể triển khai nó như một lớp độc lập là Trước khi tạo một lớp trang trí, hãy xem các lựa chọn thay thế như sau: Bạn có thể thêm mới chức năng trực tiếp vào lớp bên dưới, thay vì tạo một trang trí lớp không? Điều này có nghĩa là nếu mới chức năng có mục tiêu tương đối chung, hoặc nếu nó có liên quan về mặt logic với lớp bên dưới hoặc nếu hầu hết các cách sử dụng lớp bên dưới cũng sẽ sử dụng mới chức năng. Ví dụ: hầu hết những người tạo Java InputStream cũng sẽ tạo BufferedInputStream và bộ đệm là một phần tự nhiên của I / O, vì các lớp này nên được kết hợp với nhau. If new function is being chuyên biệt cho một trường hợp sử dụng công cụ thể, hợp nhất dữ liệu nó với trường hợp sử dụng, thay vì tạo ra một lớp riêng biệt có hợp lý không? Bạn có thể kết hợp mới chức năng nhất với một trang trí hiện tại, thay vì tạo ra một trang mới không? This will path to a layer page deep more than do nhiều nông trang. Cuối cùng, hãy tự hỏi bản thân xem chức năng mới có thực sự cần thiết để bao bọc chức năng có hay không: bạn có thể triển khai nó như một lớp độc lập không độc lập với lớp cơ sở? Trong ví dụ về cửa sổ, các thanh cuộn có thể được triển khai riêng biệt với cửa sổ chính mà không bao gồm tất cả các chức năng hiện có của nó. Đôi khi có những tình huống mà trình bao bọc có ý nghĩa. Một ví dụ là khi hệ thống sử dụng một lớp bên ngoài mà giao diện của nó không thể sửa đổi được, nhưng lớp đó phải phù hợp với một giao diện khác trong ứng dụng nơi nó đang được sử dụng. Trong trường hợp này, một lớp wrapper có thể được sử dụng để dịch giữa các giao diện. Tuy nhiên, những trường hợp như thế này rất hiếm; thường có một giải pháp thay thế tốt hơn là sử dụng một lớp trình bao bọc.